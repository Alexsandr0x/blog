<!doctype html><html lang=pt-br><head><title>Basico de Concorrência e Paralelismo em Python &ndash; Alexsandro</title><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.2/css/all.min.css integrity="sha512-1sCRPdkRXhBV2PBLUdRb4tMg1w2YPf37qatUFeS7zlBy7jJI8Lf4VHwWfZZfpXtYSLy85pkm9GaYVYMfw5BC1A==" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.1/css/academicons.min.css integrity="sha512-b1ASx0WHgVFL5ZQhTgiPWX+68KjS38Jk87jg7pe+qC7q9YkEtFq0z7xCglv7qGIs/68d3mAp+StfC8WKC5SSAg==" crossorigin=anonymous><link rel=stylesheet href=http://alexsandro.dev/css/palettes/base16-dark.css><link rel=stylesheet href=http://alexsandro.dev/css/risotto.css><link rel=stylesheet href=http://alexsandro.dev/css/custom.css></head><body><div class=page><header class=page__header><h1 class=page__logo><a href=http://alexsandro.dev/ class=page__logo-inner>Alexsandro</a></h1><nav class="page__nav main-nav"><ul><li class=main-nav__item><a class=nav-main-item href=http://alexsandro.dev/about/ title>About</a></li><li class=main-nav__item><a class=nav-main-item href=http://alexsandro.dev/posts/ title>Posts</a></li><li class=main-nav__item><a class=nav-main-item href=http://alexsandro.dev/lessons/ title>Lessons</a></li></ul></nav></header><section class=page__body><p align=right><span class=active><b>Português</b></span></p><header class=content__header><h1>Basico de Concorrência e Paralelismo em Python</h1></header><div class=content__body><p>Esse foi um conteúdo básico elaborado para a tribo de sistemas multi-robóticos da equipe de robótica <a href>Project Neon</a> em agosto de 2022. O conteúdo é aberto a membros mas eu preferi fazer uma síntese com algumas correções nesta publicação.</p><p>Tornei o conteúdo mais agnóstico removendo as referências de robótica móvel. Espero que essa tentativa de tornar os conceitos de concorrência e paralelismo fáceis de entender seja efetivo para alguém!</p><h2 id=o-que-é-paralelização>O que é Paralelização?</h2><p><strong>Paralelização</strong>, programação paralela, ou computação paralela é a <strong>forma de resolver comandos dentro de um ambiente computacional ao mesmo tempo</strong>.</p><p>Esse procedimento é muito útil em diversos segmentos da computação que precisam ter alto desempenho ou simplesmente fazer várias coisas ao mesmo tempo.</p><p>Por exemplo, o seu computador, neste momento desempenha várias ações paralelas: ele está gerenciando pacotes de rede que chegam para seu navegador, quando você escuta música ao mesmo tempo que joga um jogo, ambos softwares estão desempenhando papéis totalmente diferentes porém paralelos.</p><p><strong>Quando estamos programando um código simples, não é diferente</strong>, às vezes queremos que nosso código faça mais de uma coisa ao mesmo tempo, mas com a programação estruturada como conhecemos não é possível.</p><figure><img src=/images/python-parallelism/serial-vs-parallel.png alt="Comunicação Serial e Paralela em redes é um ótimo paralelo para nossa discussão."><figcaption><p>Comunicação Serial e Paralela em redes é um ótimo <strong>paralelo</strong> para nossa discussão.</p></figcaption></figure><p>Usualmente programamos de forma <strong>serial</strong>, ou seja, os comandos têm uma ordem lógica, bem estruturada e um por vez. Quando você aplica vários comandos <em>print</em> no python ou em qualquer linguagem você tem a certeza que eles irão sempre rodar na mesma ordem.</p><p>Agora, quando aplicamos uma estratégia paralela, podemos fazer comandos rodando ao mesmo tempo de forma independente.</p><h2 id=paralelização-vs-concorrência>Paralelização vs Concorrência</h2><p>Para entender na prática o uso de paralelização, é preciso entender dois conceitos importantíssimos: <strong>Paralelização</strong> e <strong>Concorrência</strong>. Aqui, iremos tornar a palavra paralelização mais restrita a uma definição clara enquanto teremos um novo conceito que é a concorrência.</p><p>Concorrência diz respeito a processos que executam disputando um mesmo recurso, esse recurso pode ser a memória do computador por exemplo. Dessa concorrência pode ocorrer de forma que esses processos se revezam no consumo desse recurso.</p><figure><img src=/images/python-parallelism/concurrent-model.png></figure><p>Note que no exemplo concorrente, temos duas tarefas, A e B, ambas rodam ao mesmo tempo, porém, para uma ser processada, a outra deve parar, fazendo com que o tempo total para executar as duas tarefas ao mesmo tempo seja A + B.</p><p>Paralelização já diz respeito a processos que executam de forma simultânea e independente. Podendo ou não compartilhar recursos.</p><figure><img src=/images/python-parallelism/parallel-model.png></figure><p>Já no paralelo, a execução pode ser ao mesmo tempo, no caso da imagem, rodando em CPUs diferentes. Sempre que dois processamentos forem independentes, por definição, se pode usar paralelização. Sempre que dois processamentos compartilham de algum recurso e precisam se dividir no uso dele, podemos usar a concorrência.</p><h2 id=alimentando-cachorros>Alimentando Cachorros</h2><p>Para fixar essa noção, podemos usar um conceito lúdico da disputa de dois cachorros tentando comer 1 pote de ração.</p><figure><img src=/images/python-parallelism/parallel-dogs-2.png></figure><p>Considerando os dois cachorrinhos como processos e o pote de ração como o recurso a ser disputado, a solução aqui é o caminho serial do cachorro C1 comer primeiro até que sua fome seja saciada e só depois o C2 tem a sua chance de comer.</p><p>Não é necessário ter experiência cuidando de animais para entender que esse caminho tem vários problemas, e não é diferente na orquestração de processos. Se o recurso for tempo, C1 pode demorar demais e não dar oportunidade para C2, se a quantidade de petiscos no pote for limitada C2 pode passar fome.</p><figure><img src=/images/python-parallelism/parallel-dogs-3.png></figure><p>Numa alternativa concorrente, podemos colocar os cachorrinhos C1 e C2 comerem de forma intervalada, sendo regidos por alguma regra, como tempo (cada um como por 1 min e depois dá acesso ao recurso para o outro por exemplo).</p><p>Se a regra for bem pensada evitamos problemas de escassez de recursos como tempo.</p><figure><img src=/images/python-parallelism/parallel-dogs-4.png></figure><p>Por fim, temos a solução paralela, onde ambos processos se alimentam de forma independente, porém do mesmo recurso.</p><h2 id=mão-na-massa-cachorros-no-python>Mão na Massa: Cachorros no Python!</h2><p>Agora que entendemos o que é concorrência e o que é paralelismo vamos fixar de uma vez por todas praticando esses conceitos com Python!</p><p>Para isso, vamos primeiro bolar uma classe que irá representar nossos cachorrinhos:</p><script type=application/javascript src="https://gist.github.com/Alexsandr0x/bd7b86b51fd4faccff23793249a6d893.js?file=dog.py"></script><p>Com esse código podemos inicializar diferentes cachorros de forma que eles se alimentem de uma variável <code>pot</code>. Essa variável será uma lista que terá recursos finitos. Note que o <code>food_necessary</code> é definido como 10, ou seja, para que nosso cachorro esteja saciado, ele precisará comer pelo menos 10 petiscos.</p><p>Para entender esse código antes de observar ele nas ocasiões serial, concorrente e paralela vamos entender o que acontece quando colocamos para o cachorro se alimentar.</p><script type=application/javascript src="https://gist.github.com/Alexsandr0x/bd7b86b51fd4faccff23793249a6d893.js?file=simple_use_dog.py"></script><p>Esse código nos dará o seguinte resultado:</p><figure><img src=/images/python-parallelism/dog_example.gif></figure><p>Dessa forma, sabemos o comportamento quando o cão está sozinho, 10 petiscos para se alimentar, e 10 no pote, bem simples.</p><p>Note que temos uma regra onde abaixo de 50% o cachorro pode morrer de fome! então se tivermos dois cachorros e 10 petiscos temos exatamente o necessário para alimentá-los porém na programação serial essa lógica ira sempre matar o segundo cachorro!</p><p>Agora, se tivermos dois cachorros em um código serial&mldr;</p><script type=application/javascript src="https://gist.github.com/Alexsandr0x/bd7b86b51fd4faccff23793249a6d893.js?file=double_dog.py"></script><figure><img src=/images/python-parallelism/double_dog_example.gif></figure><h2 id=python-threads-como-solução-concorrente>Python Threads como solução concorrente</h2><p>Uma solução para o caso dos dois doguinhos que disputam comida é que eles comam usando uma estratégia concorrente. Uma das soluções concorrentes do Python é o módulo <code>Thread</code>. Nele, podemos criar métodos que serão executados de forma concorrente e gerenciados pelo python entre as suas trocas. Não teremos exatamente o controle de quando um cachorro para de comer, mas o que o Python irá fazer é sempre que usamos um comando de parada de thread, como o <code>time.sleep</code>, ele irá verificar se existe outra thread apta a trabalhar enquanto a outra fica dormindo.</p><p>Para isso, precisamos fazer esse while que criamos ser um método, que chamaremos de <code>task</code>. O objeto <code>Thread</code> irá receber como parâmetro esse método, e também receberá os argumentos da função no argumento posicional <code>args</code>.</p><script type=application/javascript src="https://gist.github.com/Alexsandr0x/bd7b86b51fd4faccff23793249a6d893.js?file=thread_dogs.py"></script><p>E com isso temos&mldr;</p><figure><img src=/images/python-parallelism/thread_dogs.gif></figure><p><em>Perfectly balanced, as all things should be&mldr;</em></p><p>É importante dizer que o exemplo alcançou exatamente 50% com as duas threads se intercalando perfeitamente, mas nem sempre sera assim, ainda mais numa aplicação complexa em que o Python estará gerenciando tantas outras threads que estarão disputando recursos. Mas esse pequeno exemplo já mostra um caso onde a concorrência é benéfica.</p><h2 id=e-a-solução-paralela>E a solução paralela?</h2><p>Eu havia bolado uma explicação paralela para esse conteúdo quando o criei, hoje não estou totalmente satisfeito com ele, a abordagem paralela exige alguns conceitos complexos como compartilhamento de memória e condições de corrida que talvez caibam em outro lugar&mldr;</p><p>Quem sabe um dia revisito esse conteúdo numa parte 2 desse texto&mldr;</p><h2 id=referências>Referências</h2><p>Esse texto foi baseado no meu próprio conteúdo para uma aula que preparei focado em calouros da equipe de robótica da Universidade Federal do ABC. Que por sua vez teve como base principalmente <em><strong>Luciano Ramalho</strong> - Python Fluente</em> e <em><strong>Shaw, A</strong> - CPython internals: your guide to the Python 3 interpreter</em>.</p></div><footer class=content__footer></footer></section><section class=page__aside><div class=aside__about><ul class=aside__social-links></ul></div><hr><div class=aside__content><p>Uma tentativa de explicar concorrência e paralelização com cachorros</p><p>2022-12-28</p></div></section><footer class=page__footer><p class=copyright></p><p class=advertisement>Powered by <a href=https://gohugo.io/>hugo</a> and <a href=https://github.com/joeroe/risotto>risotto</a>.</p></footer></div></body></html>